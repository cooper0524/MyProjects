{"ast":null,"code":"/*\n *  Copyright 2011 Rackspace\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\nvar cache = {}; // Do any others need escaping?\n\nvar TO_ESCAPE = {\n  '\\'': '\\\\\\'',\n  '\\n': '\\\\n'\n};\n\nfunction populate(formatter) {\n  var i,\n      type,\n      key = formatter,\n      prev = 0,\n      arg = 1,\n      builder = 'return \\'';\n\n  for (i = 0; i < formatter.length; i++) {\n    if (formatter[i] === '%') {\n      type = formatter[i + 1];\n\n      switch (type) {\n        case 's':\n          builder += formatter.slice(prev, i) + '\\' + arguments[' + arg + '] + \\'';\n          prev = i + 2;\n          arg++;\n          break;\n\n        case 'j':\n          builder += formatter.slice(prev, i) + '\\' + JSON.stringify(arguments[' + arg + ']) + \\'';\n          prev = i + 2;\n          arg++;\n          break;\n\n        case '%':\n          builder += formatter.slice(prev, i + 1);\n          prev = i + 2;\n          i++;\n          break;\n      }\n    } else if (TO_ESCAPE[formatter[i]]) {\n      builder += formatter.slice(prev, i) + TO_ESCAPE[formatter[i]];\n      prev = i + 1;\n    }\n  }\n\n  builder += formatter.slice(prev) + '\\';';\n  cache[key] = new Function(builder);\n}\n/**\n * A fast version of sprintf(), which currently only supports the %s and %j.\n * This caches a formatting function for each format string that is used, so\n * you should only use this sprintf() will be called many times with a single\n * format string and a limited number of format strings will ever be used (in\n * general this means that format strings should be string literals).\n *\n * @param {String} formatter A format string.\n * @param {...String} var_args Values that will be formatted by %s and %j.\n * @return {String} The formatted output.\n */\n\n\nexports.sprintf = function (formatter, var_args) {\n  if (!cache[formatter]) {\n    populate(formatter);\n  }\n\n  return cache[formatter].apply(null, arguments);\n};","map":{"version":3,"sources":["/Users/Cooper/Bluxury_Catering/bluxury-catering copy 3/node_modules/ECPAY_Payment_node_js/node_modules/elementtree/lib/sprintf.js"],"names":["cache","TO_ESCAPE","populate","formatter","i","type","key","prev","arg","builder","length","slice","Function","exports","sprintf","var_args","apply","arguments"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,IAAIA,KAAK,GAAG,EAAZ,C,CAGA;;AACA,IAAIC,SAAS,GAAG;AACd,QAAM,MADQ;AAEd,QAAM;AAFQ,CAAhB;;AAMA,SAASC,QAAT,CAAkBC,SAAlB,EAA6B;AAC3B,MAAIC,CAAJ;AAAA,MAAOC,IAAP;AAAA,MACIC,GAAG,GAAGH,SADV;AAAA,MAEII,IAAI,GAAG,CAFX;AAAA,MAGIC,GAAG,GAAG,CAHV;AAAA,MAIIC,OAAO,GAAG,WAJd;;AAMA,OAAKL,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGD,SAAS,CAACO,MAA1B,EAAkCN,CAAC,EAAnC,EAAuC;AACrC,QAAID,SAAS,CAACC,CAAD,CAAT,KAAiB,GAArB,EAA0B;AACxBC,MAAAA,IAAI,GAAGF,SAAS,CAACC,CAAC,GAAG,CAAL,CAAhB;;AAEA,cAAQC,IAAR;AACE,aAAK,GAAL;AACEI,UAAAA,OAAO,IAAIN,SAAS,CAACQ,KAAV,CAAgBJ,IAAhB,EAAsBH,CAAtB,IAA2B,iBAA3B,GAA+CI,GAA/C,GAAqD,QAAhE;AACAD,UAAAA,IAAI,GAAGH,CAAC,GAAG,CAAX;AACAI,UAAAA,GAAG;AACH;;AACF,aAAK,GAAL;AACEC,UAAAA,OAAO,IAAIN,SAAS,CAACQ,KAAV,CAAgBJ,IAAhB,EAAsBH,CAAtB,IAA2B,gCAA3B,GAA8DI,GAA9D,GAAoE,SAA/E;AACAD,UAAAA,IAAI,GAAGH,CAAC,GAAG,CAAX;AACAI,UAAAA,GAAG;AACH;;AACF,aAAK,GAAL;AACEC,UAAAA,OAAO,IAAIN,SAAS,CAACQ,KAAV,CAAgBJ,IAAhB,EAAsBH,CAAC,GAAG,CAA1B,CAAX;AACAG,UAAAA,IAAI,GAAGH,CAAC,GAAG,CAAX;AACAA,UAAAA,CAAC;AACD;AAfJ;AAmBD,KAtBD,MAsBO,IAAIH,SAAS,CAACE,SAAS,CAACC,CAAD,CAAV,CAAb,EAA6B;AAClCK,MAAAA,OAAO,IAAIN,SAAS,CAACQ,KAAV,CAAgBJ,IAAhB,EAAsBH,CAAtB,IAA2BH,SAAS,CAACE,SAAS,CAACC,CAAD,CAAV,CAA/C;AACAG,MAAAA,IAAI,GAAGH,CAAC,GAAG,CAAX;AACD;AACF;;AAEDK,EAAAA,OAAO,IAAIN,SAAS,CAACQ,KAAV,CAAgBJ,IAAhB,IAAwB,KAAnC;AACAP,EAAAA,KAAK,CAACM,GAAD,CAAL,GAAa,IAAIM,QAAJ,CAAaH,OAAb,CAAb;AACD;AAGD;;;;;;;;;;;;;AAWAI,OAAO,CAACC,OAAR,GAAkB,UAASX,SAAT,EAAoBY,QAApB,EAA8B;AAC9C,MAAI,CAACf,KAAK,CAACG,SAAD,CAAV,EAAuB;AACrBD,IAAAA,QAAQ,CAACC,SAAD,CAAR;AACD;;AAED,SAAOH,KAAK,CAACG,SAAD,CAAL,CAAiBa,KAAjB,CAAuB,IAAvB,EAA6BC,SAA7B,CAAP;AACD,CAND","sourcesContent":["/*\n *  Copyright 2011 Rackspace\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\n\nvar cache = {};\n\n\n// Do any others need escaping?\nvar TO_ESCAPE = {\n  '\\'': '\\\\\\'',\n  '\\n': '\\\\n'\n};\n\n\nfunction populate(formatter) {\n  var i, type,\n      key = formatter,\n      prev = 0,\n      arg = 1,\n      builder = 'return \\'';\n\n  for (i = 0; i < formatter.length; i++) {\n    if (formatter[i] === '%') {\n      type = formatter[i + 1];\n\n      switch (type) {\n        case 's':\n          builder += formatter.slice(prev, i) + '\\' + arguments[' + arg + '] + \\'';\n          prev = i + 2;\n          arg++;\n          break;\n        case 'j':\n          builder += formatter.slice(prev, i) + '\\' + JSON.stringify(arguments[' + arg + ']) + \\'';\n          prev = i + 2;\n          arg++;\n          break;\n        case '%':\n          builder += formatter.slice(prev, i + 1);\n          prev = i + 2;\n          i++;\n          break;\n      }\n\n\n    } else if (TO_ESCAPE[formatter[i]]) {\n      builder += formatter.slice(prev, i) + TO_ESCAPE[formatter[i]];\n      prev = i + 1;\n    }\n  }\n\n  builder += formatter.slice(prev) + '\\';';\n  cache[key] = new Function(builder);\n}\n\n\n/**\n * A fast version of sprintf(), which currently only supports the %s and %j.\n * This caches a formatting function for each format string that is used, so\n * you should only use this sprintf() will be called many times with a single\n * format string and a limited number of format strings will ever be used (in\n * general this means that format strings should be string literals).\n *\n * @param {String} formatter A format string.\n * @param {...String} var_args Values that will be formatted by %s and %j.\n * @return {String} The formatted output.\n */\nexports.sprintf = function(formatter, var_args) {\n  if (!cache[formatter]) {\n    populate(formatter);\n  }\n\n  return cache[formatter].apply(null, arguments);\n};\n"]},"metadata":{},"sourceType":"script"}